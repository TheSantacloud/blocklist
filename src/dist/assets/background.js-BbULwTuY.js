let l = null; chrome.runtime.onInstalled.addListener(function() { chrome.storage.sync.set({ blockListEnabled: !0, timestamp: Date.now() }) }); chrome.webNavigation.onHistoryStateUpdated.addListener(e => { c(e.tabId, e.url) }); chrome.tabs.onUpdated.addListener(async function(e, o, t) { o.status === "complete" && c(e, t.url) }); async function c(e, o) { const { blockList: t, blockListEnabled: n } = await chrome.storage.sync.get(["blockList", "blockListEnabled"]); if (!n) return; const r = u(o, t); r && chrome.tabs.sendMessage(e, { action: "block-url", url: r, message: t[r].desc }, () => { chrome.runtime.lastError && chrome.runtime.lastError.message && (chrome.runtime.lastError.message.includes("message port closed") || console.warn(chrome.runtime.lastError.message)) }) } function u(e, o) { for (let t in o) if (e.includes(t)) return t; return null } chrome.storage.onChanged.addListener((e, o) => { if (o === "sync") { "blockListEnabled" in e && (l > 0 && (clearTimeout(l), l = null), e.blockListEnabled.newValue === !1 && chrome.storage.sync.get("timeoutValue", n => { n.timeoutValue > 0 && (l = setTimeout(() => { chrome.storage.sync.set({ blockListEnabled: !0 }) }, n.timeoutValue * 60 * 1e3)) })); for (let [t, { oldValue: n, newValue: r }] of Object.entries(e)) t === "blockListEnabled" && (t === "blockListEnabled" && n === r || chrome.storage.sync.get("blockList", i => { chrome.tabs.query({ active: !0, currentWindow: !0, windowType: "normal" }, function(s) { if (s.length) for (let a in i.blockList) s[0].url.includes(a) && chrome.tabs.reload(s[0].id) }) })) } }); chrome.commands.onCommand.addListener(async e => { e === "enable_blocklist" ? (chrome.storage.sync.set({ blockListEnabled: !0, timestamp: Date.now() }), console.log("TEST0")) : console.error("unknown command") });
